

---

## 🎯 구현 우선순위 (학생 프로젝트용)

### ⚠️ 현실 체크

이 문서의 모든 기능을 학생 프로젝트 일정 내에 완벽하게 구현하는 것은 **비현실적**입니다.
아래는 **실무 경험을 바탕으로 한 현실적인 구현 전략**입니다.

---

### ✅ 필수 구현 (MVP 보안 레이어)

**예상 소요 시간: 2~3일** (집중하면 가능)

#### 1. 비밀번호 해시 + JWT 기본 인증 ⭐ 최우선
- **난이도**: ⭐☆☆☆☆
- **시간**: 반나절
- **이유**: 기본기. 안 하면 이상함
- **구현**: `passlib.hash.bcrypt` + `python-jose`

#### 2. PII 암호화 (Fernet) ⭐ 강력 추천
- **난이도**: ⭐⭐☆☆☆
- **시간**: 1일
- **이유**: 구현 쉽고 면접 어필 포인트 최고
- **구현**: User 모델의 `phone_number`, `account_number` 암호화

#### 3. Rate Limiting ⭐ 강력 추천
- **난이도**: ⭐☆☆☆☆
- **시간**: 반나절
- **이유**: 면접관이 좋아함
- **⚠️ 중요**: **Redis 사용 필수!** 메모리 기반은 Scale-out 시 문제

```python
# ✅ 올바른 방법 (Redis 사용)
from slowapi import Limiter
limiter = Limiter(
    key_func=get_remote_address,
    storage_uri="redis://localhost:6379"  # Redis!
)
```

#### 4. 보안 헤더 미들웨어
- **난이도**: ⭐☆☆☆☆
- **시간**: 30분
- **이유**: 복붙 수준. 효과 대비 노력 최고

#### 5. 감사 로그 (⚠️ 파일만!)
- **난이도**: ⭐☆☆☆☆
- **시간**: 1시간
- **⚠️ 중요**: **DB 저장 절대 금지!** 성능 폭망

```python
# ✅ 올바른 방법 (파일 로그)
logger.info(f"{client_ip} - {method} {path} {status_code} - {process_time}s")

# ❌ 절대 하지 말 것 (DB 직접 저장)
# audit_log = AuditLog(...)  # 모든 요청마다 INSERT → DB 부하
# db.add(audit_log)
```

**면접 답변**:
> "원래는 audit_logs 테이블에 저장하도록 설계했으나, PostgreSQL에 로그를 직접 쌓으면 
> 트래픽 증가 시 성능 병목이 발생합니다. 따라서 파일 로그로 남기고, 
> 추후 ELK 스택이나 CloudWatch 도입을 계획했습니다."

---

### 🧩 설계만 보여줄 것 (문서 + 부분 코드)

#### 6. JWT 블랙리스트 ❌ 풀 구현 비추천
- **문제점**: 
  - Redis 인프라 필수
  - 로그인 전체 로직 수정 필요
  - 테스트 케이스 대폭 증가
- **대안**: **Refresh Token 만료시간을 15분으로 짧게 설정**

**면접 답변**:
> "JWT 블랙리스트를 설계했으나, Redis 인프라 미구축 및 일정 고려로 
> Refresh Token 만료시간을 짧게 설정하는 방향으로 우회했습니다."

#### 7. RBAC 전체 적용 ❌ 완전 구현 비추천
- **문제점**: 모든 API에 일관성 있게 적용 어려움
- **대안**: 핵심 관리자 API 2~3개에만 데코레이터 적용

#### 8. 감사 로그 알림 (Slack) ❌ 풀 구현 비추천
- **문제점**: 패턴 분석 + 스케줄링 = 미니 프로젝트급
- **대안**: Slack Webhook 코드 예시만

#### 9. 데이터 파기 스크립트 ❌ 풀 구현 비추천
- **문제점**: 운영/DevOps 영역, 시간 과다 소요
- **대안**: 스크립트 예시 코드 + 정책 문서

---

## ⚠️ 성능 함정 (절대 하지 말 것)

### 1. 감사 로그를 RDBMS에 저장 ❌
**문제**: 모든 요청마다 INSERT → DB 부하 폭증

```python
# ❌ 이렇게 하면 트래픽 좀만 늘어도 DB 터짐
async def log_to_db(request, response):
    db.add(AuditLog(...))  # 모든 요청마다!
    await db.commit()      # DB I/O!
```

**현업 방식**: ELK, CloudWatch, Datadog, Loki 등 전용 로그 시스템 사용

---

### 2. JWT 블랙리스트를 PostgreSQL에서 조회 ❌
**문제**: 모든 인증 요청마다 SELECT → 병목 1순위

```python
# ❌ 이렇게 하면 모든 API 호출이 느려짐
async def verify_token(token: str):
    is_blacklisted = db.query(JWTBlacklist).filter(...).first()  # 매번 DB 조회!
```

**현업 방식**: Redis (인메모리) 필수

```python
# ✅ Redis 사용
is_blacklisted = redis_client.exists(f"blacklist:{jti}")  # 초고속 조회
```

---

### 3. Rate Limiting을 메모리 변수로 ❌
**문제**: 서버 여러 대 → 각자 따로 카운트 → 의미 없음

**현업 방식**: Redis 또는 API Gateway/AWS WAF에서 처리

---

## 🎓 면접 전략

### "왜 안 했어요?" 질문 대응법

#### ❌ 나쁜 답변
- "시간이 없어서요"
- "구현이 어려워서요"
- "몰랐어요"

#### ✅ 시니어급 답변 (트레이드오프 설명)

**Q: 왜 감사 로그를 DB에 저장 안 했나요?**

> "처음에는 PostgreSQL audit_logs 테이블에 저장하도록 설계했습니다.
> 하지만 RDBMS에 로그를 직접 저장하면 트래픽 증가 시 **성능 병목**이 발생할 것으로 판단했습니다.
> 따라서 현재는 **파일 로그**로 남기고, 추후 **ELK 스택이나 CloudWatch** 도입을 통해 
> 로그 수집·분석 파이프라인을 구축하는 방향으로 전환했습니다."

→ **"설계는 할 줄 알되, 현실적인 제약을 알고 타협했다"는 시니어급 사고방식**

**Q: Rate Limiting을 nginx 같은 인프라에서 안 하고 왜 코드로 했나요?**

> "이상적으로는 API Gateway나 Nginx에서 처리하는 게 맞습니다.
> 하지만 현재 학생 프로젝트 환경에서는 **인프라 설정 권한이 제한**적이고,
> 애플리케이션 레벨에서 세밀한 제어(경로별 다른 제한)를 보여드리고자 
> **slowapi + Redis**로 구현했습니다.
> 실제 프로덕션에서는 Cloudflare WAF나 AWS API Gateway를 우선 고려할 것입니다."

---

## 📊 구현 vs 설계 비교표

| 기능 | 구현 | 설계만 | 이유 |
|------|------|--------|------|
| 비밀번호 해시 + JWT | ✅ 필수 | - | 기본기 |
| PII 암호화 | ✅ 필수 | - | 어필 최고 |
| Rate Limiting | ✅ 필수 | - | 쉽고 효과적 |
| 보안 헤더 | ✅ 권장 | - | 30분 투자 |
| 감사 로그 (파일) | ✅ 권장 | - | 1시간 투자 |
| JWT 블랙리스트 | - | ✅ | Redis 필수, 복잡 |
| RBAC 전체 | - | ✅ | 일관성 유지 어려움 |
| Slack 알림 | - | ✅ | 시간 대비 효과 낮음 |
| 데이터 파기 | - | ✅ | 운영 영역 |

---

## 🏆 최종 권장사항

1. **구현**: 위의 필수 5가지 (2~3일 집중)
2. **문서**: 나머지는 설계 문서와 부분 코드
3. **발표**: "우선순위 판단", "트래픽 고려", "인프라 활용" 강조

**이 정도면 "보안까지 제대로 생각하는 팀"이라는 평가를 받으면서도, 프로젝트 일정을 지킬 수 있습니다.**

---

**Made with 🛡️ Security First & 🎯 Reality Check**
